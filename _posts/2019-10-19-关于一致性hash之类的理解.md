## 一致性hash  
不管是一致性hash，还是引入了虚拟节点的一致性hash，都是为了减少节点变化后，缓存_大面积_失效，目前没有什么算法说100%不失效。以前一直看各种文章介绍一致性
hash虚拟环，产生了误解，比如某个节点被剔除（主动或者故障）后，看图上都觉得是 keys带数据都自动顺时钟方向漂移到新节点，这是理解错误。实际上只是说这个key的
路由规则漂移到了下一个节点。比如存在A(k1)、B(k2)、C(k3)，3个节点，括号中为分配的Key，假如B节点剔除了，那么k2的路由规则会漂移到C节点。 那么此时客户端请
求 get k2的时候，则是到C节点去查，自然这里没有k2的存在，则需要穿透缓存，从数据库读出，然后按照一定缓存规则将数据也写到C节点，下一次再 get k2 则命中缓存。  
一致性hash有什么不足呢？  
+ 雪崩效应
A节点崩溃后，那么以后B节点要承受成倍的压力，B节点受不了崩溃后，C节点承受更厉害的压力，最后如果都顶不住，整个系统就崩溃了。  
更复杂的结构就是，hash环上每个节点又搞成集群或者主备保障。
+ 脏数据
这个大概率由服务端与客户端网络不畅导致的，但由于节点本身没有问题，所以没有被剔除hash环，此时 put的数据被插入到了下一个节点上，但是下次网络通畅后 get时，
又回到了上一个节点，读到的是脏数据。

## Redis的slot  
也是减少缓存大面积失效的一种，比一致性hash打的更散，所以影响更小。
